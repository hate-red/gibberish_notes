*Сортировка* - упорядочение некоторого множества элементов
##### Сортировка включает
1. Правило, которое определяет упорядоченность пары - *ключ сортировки*, *правило сравнения*
2. Порядок сортировка (возрастание, убывание)
3. Непосредственно сортирующий алгоритм

## Виды сортировки
### 1. Сортировка поиском (выбором)
**Идея:** 

| 1   | 2   | 3   |  [  |  5  |  ]  |  9  |  8  |  4  |
| --- | --- | --- | :-: | :-: | :-: | :-: | :-: | :-: |
Выбираем элемент на границе отсортированной части и не отсортированной

| 1   | 2   | 3   |  4  |  [  |  9  |  ]  |  8  |  4  |
| --- | --- | --- | :-: | :-: | :-: | :-: | :-: | :-: |
 ищем локальный минимум и меняем местами элементы


```C++
size_t n = 10;
int a[n];


for (size_t i = 0; i < n - 1; i++) {
	size_t local_min_ind = i;
	
	// Ищем локальный минимум
	for (size_t j = i + 1; j < n - 1; j++) {
		if (a[j] < a[local_min_ind]) {
			local_min_ind = j;
		}
	}
	// меняем местами элементы
	std::swap(a[i], a[local_min_ind]);
}
```

### 2. Сортировка вставками
Берем элемент и, перебирая элементы, смотрим куда его можно поставить в левую, упорядоченную часть

>Вариант 1
```C++
size_t n = 10;
int a[n];


for (size_t i = 1; i < n; i++) {
	// Берем элемент справа и двигаем влево
	for (size_t j = i; j > 0 && a[j] < a[j - 1]; j--) {
		// из-за свапа алгоритм неэффективен
		swap(a[j - 1], a[j]);
	}
}
```

>Вариант 2
```C++
size_t n = 10;
int a[n];

// Более эффективен, за счет сохранения во временную переменную, а не свапа
for (size_t i = 1; i < n; i++) {
	int tmp = a[i];
	size_t j = i;
	
	while (j > 0 && tmp < a[j -1]) {
		a[j] = a[j - 1];
		j--;
	}
	a[j] = tmp;
}
```

### 3. Сортировка пузырьком

Постепенно проходим по массиву и если элемент справа больше текущего, меняем их местами. Самые большие элементы "всплывают" в конец массива

```C++
// переменная для того, чтобы понимать, 
// есть ли смысл перебирать массив
bool f = true;
int j = 0;

while (f) {
	// надеемся, что все получится за один проход
	f = false;
	
	for (size_t i = 0; i + j + 1 < n; i++) {
		if (a[i] > a[i + 1]) {
			std::swap(a[i], a[i + 1]);
			// если хоть раз поменяли элементы, 
			// то имеет смысл еще раз пройтись по массиву
			f = true;
		}
	}
	j++;
}
```


### 4. Сортировка слиянием

Делим массив пополам, до тех пор пока не доделим до массивов из одного элемента, после начинаем процедуру слияния

```C++
// merge возвращает слитый массив из 2 частей
void merge(int a[], int left, int mid, int right) {
	int size = right - left + 1;
	int* tmp = new int[size];
	
	int i = left; 
	int j = mid + 1; 
	int k = 0;
	
	// [... , left, ... mid, mid + 1, ... , right, ...]
	// пока оба массива еще не закончились
	while (i <= mid && j <= right) {
		// элемент поменьше записываем по k-му индексу
		// в новый массив
		if (a[i] <= a[j]) {
			tmp[k++] = a[i++];
		} else {
			tmp[k++] = a[j++];
		}
	}
	// если элементы остались в каком-то из масивов, 
	// то оставшиеся элементы докидываем в tmp,
	// и после этого (!) увеличиваем счетчики
	while (i <= mid) tmp[k++] = a[i++];
	while (j < right) tmp[k++] = a[j++];
	
	for (int k = 0; k < size; k++) {
		a[left + k] = tmp[k];
	}
	
	delete[] tmp; 
}

// непосредственно алгоритм сортировки
void mergeSort(int a[], int left, int right) {
	// делим массив, пока можем
	if (left < right) {
		// находим середину
		int mid = left + (right - left) / 2;
		
		// делим пополам
		mergeSort(a, left, mid);
		mergeSort(a, mid + 1, right);
		
		// сливаем результаты
		merge(a, left, mid, right);
	}
}
```

>Имеет сложность O(n log(n)) 


## Оценка алгоритмов (доп.)

*Временная сложность* - время выполнения / количество элементарных операций, необходимых для выполнения алгоритма (учитывается, как растет время выполнения, при увеличении входных данных)

*Пространственная сложность* - объем памяти, который требуется алгоритму для выполнения

Среди прочих критериев:
- устойчивость
- корректность
- простота реализации
- универсальность



